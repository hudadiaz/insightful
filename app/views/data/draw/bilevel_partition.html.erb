<style>

#main {
  float: left;
  width: 750px;
}

#sidebar {
  float: right;
  width: 100px;
}

#sequence {
  width: 600px;
  height: 70px;
}

#legend {
  padding: 10px 0 0 3px;
}

#sequence text, #legend text {
  font-weight: 600;
  fill: #fff;
}

#chart {
  position: relative;
}

#chart path {
  stroke: #fff;
}

#explanation {
  position: absolute;
  top: 260px;
  left: 305px;
  width: 140px;
  text-align: center;
  color: #666;
  z-index: -1;
}

#percentage {
  font-size: 2.5em;
}

</style>

<h1>Draw#bilevel_partition</h1>

<div class="row">
  <div class="col-sm-4">
    <div class="form-group">
      <label for="select-cat">Compare</label>
      <select id="select-cat" class="form-control">
        <option disabled selected> loading... </option>
      </select>
    </div>
  </div>
  <div class="col-sm-4">
    <div class="form-group">
      <label for="select-stack">On</label>
      <select id="select-stack" class="form-control">
        <option disabled selected> loading... </option>
      </select>
    </div>
  </div>
  <div class="col-sm-4">
    <div class="form-group">
      <label for="select-measure">According to</label>
      <select id="select-measure" class="form-control">
        <option disabled selected> loading... </option>
      </select>
    </div>
  </div>
</div>

<div class="row" id="selectedItem">
</div>

<div id="main">
  <div id="sequence"></div>
  <div id="chart">
    <div id="explanation" style="visibility: hidden;">
      <span id="percentage"></span><br/>
      of visits begin with this sequence of pages
    </div>
  </div>
</div>
<div id="sidebar">
  <input type="checkbox" id="togglelegend"> Legend<br/>
  <div id="legend" style="visibility: hidden;"></div>
</div>
  <!-- <pre id="json"></pre> -->

<script>
  var data, levels = ["Hair", "Sex", "Eye"];

  // drawStackedBars(data);
  var req = $.get("<%= datum_path(@datum, format: :json) %>");

  $.when(req).done(function(res) {
    data = res;
    // $.each(selects, function(i, val) {
    //   updateSelect(i, val, data["headers"]);
    // })

    draw();
  });

  var updateSelect = function(index, id, keys) {
    $.each(keys, function(i, key) {
      if (index == 0 && !isNaN(data["values"][key][0])) return true;
      if (index == 1 && (data["values"][key].length > 9 || !isNaN(data["values"][key][0]))) return true;
      if (index == 2 && isNaN(data["values"][key][0])) return true;
      $("#select-"+id)
        .append($("<option></option>")
        .attr("value",key)
        .text(key)); 
    })
    $("#select-"+id).selectize();
    $("#select-"+id).change(function() {
      draw();
    })
  }

  var draw = function() {
    reset()
    var valid = true;

    // $.each(selects, function(i, id) {
    //   if ($("#select-"+id).val().length < 1) valid = false;
    //   obj[id] = $("#select-"+id).val();
    // })

    if (valid)
      processData(levels, false, function(processedData){
        // drawStackedBars(processedData, obj.cat, obj.measure)
          // $("#json").html(JSON.stringify(processedData, undefined, 2))
          var values = [];
          $.each(levels, function(k, v) {values = values.concat(data["values"][v])});
          console.log(values)
          createVisualization(processedData, values);
      });
  }

  var reset = function() {
    $("#chart").html("")
  }

  var processData = function(levels, measure, callback) {
    var items = JSON.parse(JSON.stringify(data["items"]));
    var processedData = {name: "root", children: []};

    var time = new Date().getTime();

    $.each(items, function(key, item) {
      var node = {name: null, children: [], size: 0};
      var i = 0, max_i = levels.length;

      var f = function(parent_node, current_node, i) {
        if(i == max_i) return;
        var existing = parent_node.children[findWithAttr(parent_node.children, "name", item[levels[i]])]


        if (existing != undefined) {
          current_node = existing;
          f(current_node, {name: null, children: [], size: 0}, ++i);
          return
        }
        else {
          current_node.name = item[levels[i]];
        }

        f(current_node, {name: null, children: [], size: 0}, ++i);

        if (current_node.children.length < 1){
          delete current_node.children;
          current_node.size = item["Freq"]
        }

        if (current_node.size < 1)
          delete current_node.size;

        parent_node.children.push(current_node);
      }
      f(processedData, node, i)
    })

    console.log(new Date().getTime()-time)

    callback(processedData);
  }

  // taken from http://stackoverflow.com/a/7178381
  function findWithAttr(array, attr, value) {
    for(var i = 0; i < array.length; i += 1) {
        if(array[i][attr] === value) {
            return i;
        }
    }
  }

// Main function to draw and set up the visualization, once we have the data.
function createVisualization(json, values) {

// Dimensions of sunburst.
  var width = 750;
  var height = 600;
  var radius = Math.min(width, height) / 2;

  // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
  var b = {
    w: 75, h: 30, s: 3, t: 10
  };

  // Mapping of step names to levels.
  var color = d3.scale.category20();
  var levels = {};

  $.each(values, function(k, v) {
    levels[v] = color(v);
  })


  // Total size of all segments; we set this later, after loading the data.
  var totalSize = 0; 

  var vis = d3.select("#chart").append("svg:svg")
      .attr("width", width)
      .attr("height", height)
      .append("svg:g")
      .attr("id", "container")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

  var partition = d3.layout.partition()
      .size([2 * Math.PI, radius * radius])
      .value(function(d) { return d.size; });

  var arc = d3.svg.arc()
      .startAngle(function(d) { return d.x; })
      .endAngle(function(d) { return d.x + d.dx; })
      .innerRadius(function(d) { return Math.sqrt(d.y); })
      .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });

    // Basic setup of page elements.
    initializeBreadcrumbTrail();
    drawLegend();
    d3.select("#togglelegend").on("click", toggleLegend);

  // Bounding circle underneath the sunburst, to make it easier to detect
  // when the mouse leaves the parent g.
  vis.append("svg:circle")
      .attr("r", radius)
      .style("opacity", 0);

  // For efficiency, filter nodes to keep only those large enough to see.
  var nodes = partition.nodes(json)
      .filter(function(d) {
      return (d.dx > 0.005); // 0.005 radians = 0.29 degrees
      });

  var path = vis.data([json]).selectAll("path")
      .data(nodes)
      .enter().append("svg:path")
      .attr("display", function(d) { return d.depth ? null : "none"; })
      .attr("d", arc)
      .attr("fill-rule", "evenodd")
      .style("fill", function(d) { return color(d.name); })
      .style("opacity", 1)
      .on("mouseover", mouseover);

  // Add the mouseleave handler to the bounding circle.
  d3.select("#container").on("mouseleave", mouseleave);

  // Get total size of the tree = value of root node from partition.
  totalSize = path.node().__data__.value;

  // Fade all initializeBreadcrumbTrail the current sequence, and show it in the breadcrumb trail.
  function mouseover(d) {

    var percentage = (100 * d.value / totalSize).toPrecision(3);
    var percentageString = percentage + "%";
    if (percentage < 0.1) {
      percentageString = "< 0.1%";
    }

    d3.select("#percentage")
        .text(percentageString);

    d3.select("#explanation")
        .style("visibility", "");

    var sequenceArray = getAncestors(d);
    updateBreadcrumbs(sequenceArray, percentageString);

    // Fade all the segments.
    d3.selectAll("path")
        .style("opacity", 0.3);

    // Then highlight only those that are an ancestor of the current segment.
    vis.selectAll("path")
        .filter(function(node) {
                  return (sequenceArray.indexOf(node) >= 0);
                })
        .style("opacity", 1);
  }

  // Restore everything to full opacity when moving off the visualization.
  function mouseleave(d) {

    // Hide the breadcrumb trail
    d3.select("#trail")
        .style("visibility", "hidden");

    // Deactivate all segments during transition.
    d3.selectAll("path").on("mouseover", null);

    // Transition each segment to full opacity and then reactivate it.
    d3.selectAll("path")
        .transition()
        .duration(1000)
        .style("opacity", 1)
        .each("end", function() {
                d3.select(this).on("mouseover", mouseover);
              });

    d3.select("#explanation")
        .style("visibility", "hidden");
  }

  // Given a node in a partition layout, return an array of all of its ancestor
  // nodes, highest first, but excluding the root.
  function getAncestors(node) {
    var path = [];
    var current = node;
    while (current.parent) {
      path.unshift(current);
      current = current.parent;
    }
    return path;
  }

  function initializeBreadcrumbTrail() {
    // Add the svg area.
    var trail = d3.select("#sequence").append("svg:svg")
        .attr("width", width)
        .attr("height", 50)
        .attr("id", "trail");
    // Add the label at the end, for the percentage.
    trail.append("svg:text")
      .attr("id", "endlabel")
      .style("fill", "#000");
  }

  // Generate a string that describes the points of a breadcrumb polygon.
  function breadcrumbPoints(d, i) {
    var points = [];
    points.push("0,0");
    points.push(b.w + ",0");
    points.push(b.w + b.t + "," + (b.h / 2));
    points.push(b.w + "," + b.h);
    points.push("0," + b.h);
    if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
      points.push(b.t + "," + (b.h / 2));
    }
    return points.join(" ");
  }

  // Update the breadcrumb trail to show the current sequence and percentage.
  function updateBreadcrumbs(nodeArray, percentageString) {

    // Data join; key function combines name and depth (= position in sequence).
    var g = d3.select("#trail")
        .selectAll("g")
        .data(nodeArray, function(d) { return d.name + d.depth; });

    // Add breadcrumb and label for entering nodes.
    var entering = g.enter().append("svg:g");

    entering.append("svg:polygon")
        .attr("points", breadcrumbPoints)
        .style("fill", function(d) { return color(d.name); });

    entering.append("svg:text")
        .attr("x", (b.w + b.t) / 2)
        .attr("y", b.h / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .text(function(d) { return d.name; });

    // Set position for entering and updating nodes.
    g.attr("transform", function(d, i) {
      return "translate(" + i * (b.w + b.s) + ", 0)";
    });

    // Remove exiting nodes.
    g.exit().remove();

    // Now move and update the percentage at the end.
    d3.select("#trail").select("#endlabel")
        .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
        .attr("y", b.h / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .text(percentageString);

    // Make the breadcrumb trail visible, if it's hidden.
    d3.select("#trail")
        .style("visibility", "");

  }

  function drawLegend() {

    // Dimensions of legend item: width, height, spacing, radius of rounded rect.
    var li = {
      w: 75, h: 30, s: 3, r: 3
    };

    var legend = d3.select("#legend").append("svg:svg")
        .attr("width", li.w)
        .attr("height", d3.keys(levels).length * (li.h + li.s));

    var g = legend.selectAll("g")
        .data(d3.entries(levels))
        .enter().append("svg:g")
        .attr("transform", function(d, i) {
                return "translate(0," + i * (li.h + li.s) + ")";
             });

    g.append("svg:rect")
        .attr("rx", li.r)
        .attr("ry", li.r)
        .attr("width", li.w)
        .attr("height", li.h)
        .style("fill", function(d) { return d.value; });

    g.append("svg:text")
        .attr("x", li.w / 2)
        .attr("y", li.h / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", "middle")
        .text(function(d) { return d.key; });
  }

  function toggleLegend() {
    var legend = d3.select("#legend");
    if (legend.style("visibility") == "hidden") {
      legend.style("visibility", "");
    } else {
      legend.style("visibility", "hidden");
    }
  }
};

</script>

